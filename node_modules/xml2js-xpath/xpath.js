'use strict';

var _ = require("lodash");

var ATTRKEY = '$';
var CHARKEY = '_';

// Definition of an XML name tag: https://www.w3.org/TR/xml/#NT-Name
var NAME_START_CHAR = 'A-Za-z:_\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D' + '\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF' + '\uF900-\uFDCF\uFDF0-\uFFFD';
var NAME_CHAR = NAME_START_CHAR + '.0-9\xB7\u0300-\u036F\u203F-\u2040-';
var TAG_NAME = '[' + NAME_START_CHAR + '][' + NAME_CHAR + ']*';
var TAG_AND_PROP = '(' + TAG_NAME + ')\\[@([\\w:]+)=\'([^\']+)\'\\]';

// Given a JSON document returned by xml2js (with _ and $ keys), return the
// combined text value of the tags.
var jsonText = function jsonText(json) {
	if (_.isString(json)) {
		return json;
	}
	var result = json[CHARKEY] || '';
	_.forEach(_.keys(json), function (key) {
		if (key === ATTRKEY || key === CHARKEY) {
			return;
		}
		var value = json[key];
		if (_.isArray(value)) {
			_.forEach(value, function (entry) {
				result += jsonText(entry);
			});
		} else {
			result += jsonText(value);
		}
	});
	return result;
};

var findAllKeys = function findAllKeys(json, key, matches) {
	if (_.isString(json)) {
		return matches;
	}
	_.forEach(_.keys(json), function (jsonKey) {
		if (jsonKey === ATTRKEY || jsonKey === CHARKEY) {
			return;
		}
		if (key === jsonKey && key in json) {
			if (!_.isArray(json[jsonKey])) {
				matches.push(json[jsonKey]);
			} else {
				_.forEach(json[jsonKey], function (val) {
					matches.push(val);
				});
			}
		} else {
			findAllKeys(json[jsonKey], key, matches);
		}
	});
	return matches;
};

var findAllProperties = function findAllProperties(json, property, matches) {
	var foundMatch = false;
	_.forEach(_.keys(json.$), function (jsonProperty) {
		if (property === jsonProperty && property in json.$) {
			matches.push(json);
			foundMatch = true;
		}
	});

	if (!foundMatch) {
		_.forEach(_.keys(json), function (jsonKey) {
			if (jsonKey === ATTRKEY || jsonKey === CHARKEY) {
				return;
			}
			findAllProperties(json[jsonKey], property, matches);
		});
	}

	return matches;
};

// Perform simple search of a xml2js document with XPath.
//
// This function supports simple XPath queries like:
//	* //Element/SubElement
//	* /Element/Subelement/SubSubElement
//	* //Element[@id='4']/SubElement
//	* //Element[@id='4']/@property
//
// Returns an array of matches.
var find = function find(json, path) {
	if (path === "") {
		if (!_.isArray(json)) {
			return [json];
		}
		return json;
	}
	if (path.length > 0 && path[0] === ".") {
		path = path.substring(1);
	}

	// match /Element[@key='value']
	var match = path.match('^\\/' + TAG_AND_PROP);
	if (match) {
		var node = match[1];
		var key = match[2];
		var value = match[3];
		var newPath = path.replace('/' + node + '[@' + key + '=\'' + value + '\']', "");
		if (node in json) {
			if (ATTRKEY in json[node]) {
				if (key in json[node][ATTRKEY] && json[node][ATTRKEY][key] === value) {
					return find(json[node], newPath);
				}
			} else if (_.isArray(json[node])) {
				var results = [];
				_.forEach(json[node], function (item) {
					if (ATTRKEY in item && key in item[ATTRKEY] && item[ATTRKEY][key] === value) {
						var hits = find(item, newPath);
						results = results.concat(hits);
					}
				});
				return results;
			}
		}
	}

	// match //Element[@key='value']
	match = path.match('^\\/\\/' + TAG_AND_PROP);
	if (match) {
		// see if the current dictionary has a match, for all that do not match, see
		// if their values have matches, etc...
		var _node = match[1];
		var _key = match[2];
		var _value = match[3];
		var _newPath = path.replace('//' + _node + '[@' + _key + '=\'' + _value + '\']', "");
		var foundKeys = findAllKeys(json, _node, []);
		var matches = _.filter(foundKeys, function (val) {
			if (ATTRKEY in val) {
				return _key in val[ATTRKEY] && val[ATTRKEY][_key] === _value;
			}
			return false;
		});
		var _results = [];
		_.forEach(matches, function (item) {
			var hits = find(item, _newPath);
			_results = _results.concat(hits);
		});
		return _results;
	}

	// match //Element
	match = extractAllKeys(json, path, new RegExp('^//([' + NAME_START_CHAR + '][' + NAME_CHAR + ']*)'));
	if (match) {
		return match;
	}

	// match intermediate /Element/
	match = path.match('^\\/(' + TAG_NAME + ')\\/');
	if (match) {
		var _node2 = match[1];
		if (_.isArray(json[_node2])) {
			var _results2 = [];
			json[_node2].forEach(function (sub) {
				return _results2 = _results2.concat(find(sub, path.replace('/' + _node2 + '/', "/")));
			});
			return _results2;
		} else {
			return find(json[_node2], path.replace('/' + _node2 + '/', "/"));
		}
	}

	// match leaf /Element
	match = path.match('^\\/(' + TAG_NAME + ')$');
	if (match) {
		var _node3 = match[1];
		if (_.has(json, _node3)) {
			if (_.isArray(json[_node3])) {
				return json[_node3];
			} else {
				return [json[_node3]];
			}
		}
	}

	// match //@property
	match = extractAllProperties(json, path, /^\/\/@([\w:]+)/);
	if (match) {
		return match;
	}

	// match /@property
	match = path.match(/^\/@([\w:]+)/);
	if (match) {
		var _matches = [];
		_.forEach(_.keys(json), function (key) {
			if (_.isArray(json[key])) {
				_.forEach(json[key], function (sub) {
					if (_.has(sub, ATTRKEY) && match[1] in sub[ATTRKEY]) {
						_matches.push(sub);
					}
				});
			} else {
				if (_.has(json, ATTRKEY) && match[1] in json[ATTRKEY]) {
					_matches.push(json);
				}
			}
		});
		return _matches;
	}
	return [];
};

var extractAll = function extractAll(json, path, pattern, extractFn) {
	var match = path.match(pattern);
	if (match) {
		// see if the current dictionary has a match, for all that do not match, see
		// if their values have matches, etc...
		var newPath = path.replace(pattern, '');
		var matches = extractFn(json, match[1], []);
		var results = [];
		_.forEach(matches, function (value) {
			var matches = find(value, newPath);
			results = results.concat(matches);
		});
		return results;
	}

	return false;
};
var extractAllKeys = _.partialRight(extractAll, findAllKeys);
var extractAllProperties = _.partialRight(extractAll, findAllProperties);

// Use find to search a JSON object.
//
// Parameters:
//	* json	= the JSON document to search (genearted by xml2js)
//	* path	= An XPath search.
//	* fetch = If true, run jsonText() on the output. If a string, try to return
//						the tag property. If not supplied, return the node.
//
// Returns a node (one with no attributes and a null value if no match)
// If more than one match is found, the first is returned.
var evalFirst = function evalFirst(json, path, fetch) {
	var matches = find(json, path);
	if (matches.length === 0) {
		if (fetch) {
			return undefined;
		}
		return undefined;
	}
	// searches like //Somehting/SomethingElse return nested arrays
	matches = matches[0];
	if (_.isArray(matches)) {
		matches = matches[0];
	}
	if (fetch === true) {
		return jsonText(matches);
	}
	if (_.isString(fetch)) {
		if (ATTRKEY in matches && fetch in matches[ATTRKEY]) {
			return matches[ATTRKEY][fetch];
		}
		return undefined;
	}
	return matches;
};

module.exports.evalFirst = evalFirst;
module.exports.find = find;
module.exports.jsonText = jsonText;

